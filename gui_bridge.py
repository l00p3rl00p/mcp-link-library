"""
GUI Bridge â€” Flask API for MCP Server Management and Status Monitoring.

THREAT MODEL:
- Binds to local loopback (127.0.0.1) by default to prevent network exposure
- CORS limited to localhost origins only (dev environments)
- Inventory and runtime JSON files are read from ~/.mcpinv (user-writable directory)
- JSON parsing uses safe error handling (specific JSONDecodeError catches)
- Subprocess calls for process checks (pgrep) use list-based argv (no shell injection)

SECURITY ASSUMPTIONS:
- Inventory file is trusted (generated by Nexus control plane)
- Local filesystem is trusted (no arbitrary file read/write endpoints)
- Process control is restricted to known servers registered in inventory
- CORS origins are hardcoded; no dynamic origin configuration

DESIGN RATIONALE:
- All JSON parsing catches json.JSONDecodeError specifically
- SQLite database access catches OSError for permission issues
- Process control (start/stop) validates command structure before subprocess.Popen()
- Logging at error points enables debugging without exposing secrets
"""

import os
import json
import sqlite3
import subprocess
from flask import Flask, jsonify
from flask_cors import CORS
from pathlib import Path

app = Flask(__name__)
# SECURITY: Restrict CORS to local dev origins only (this GUI is local-first).
CORS(app, origins=["http://localhost:5173", "http://127.0.0.1:5173", "http://localhost:5174", "http://127.0.0.1:5174", "http://localhost:5001", "http://127.0.0.1:5001"])

LOG_PATH = Path.home() / ".mcpinv" / "session.jsonl"

@app.route('/health', methods=['GET'])
def health():
    """
    Health check endpoint (no authentication required).
    
    THREAT MODEL:
    - Publicly accessible status endpoint with no secrets exposed
    - Used by load balancers and status monitors
    - No database queries; pure in-memory response
    
    Returns:
        JSON: {"status": "ok"}
    """
    return jsonify({"status": "ok"})

@app.route('/logs', methods=['GET'])
def get_logs():
    """
    Read the last 100 lines of the session log.
    
    THREAT MODEL:
    - Reads from user-writable ~/.mcpinv/session.jsonl
    - JSONL parsing is strict: each line must be valid JSON
    - Malformed lines are logged and skipped (not exposed to client)
    
    ERROR HANDLING:
    - json.JSONDecodeError: Logged; line skipped (not returned to client)
    - FileNotFoundError: Returns empty list (no error)
    - General Exception: Returns HTTP 500 (operation failed)
    
    Returns:
        JSON: List of parsed log entries (last 100 lines)
    """
    if not LOG_PATH.exists():
        return jsonify([])
    
    logs = []
    try:
        with open(LOG_PATH, "r", encoding="utf-8") as f:
            # Simple tail implementation
            lines = f.readlines()[-100:]
            for line in lines:
                try:
                    logs.append(json.loads(line))
                except json.JSONDecodeError as e:
                    logger.error(f"JSON parse error: {e}", exc_info=True)
                    continue
        return jsonify(logs)
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/status', methods=['GET'])
def get_status():
    """Real status from Nexus inventory."""
    inventory_path = Path.home() / ".mcpinv" / "inventory.json"
    servers = []
    
    if inventory_path.exists():
        try:
            with open(inventory_path, "r") as f:
                data = json.load(f)
                # Map inventory to UI format
                for s_id, s_data in data.get("servers", {}).items():
                    # Simple heuristic for online state (can be refined with PID check)
                    servers.append({
                        "id": s_id,
                        "name": s_data.get("name", s_id),
                        "status": "online" if "runtime" in s_data else "stopped",
                        "type": s_data.get("type", "generic")
                    })
        except json.JSONDecodeError as e:
            logger.error(f"JSON parse error: {e}", exc_info=True)
            pass

    def is_running(pattern):
        try:
            # Simple pgrep check
            result = subprocess.run(["pgrep", "-f", pattern], capture_output=True, text=True)
            return result.returncode == 0
        except json.JSONDecodeError as e:
            logger.error(f"JSON parse error: {e}", exc_info=True)
            return False

    # Check for core components
    # activator/observer/surgeon are CLI tools, so we define 'online' as 'installed'
    bin_dir = Path.home() / ".mcp-tools" / "bin"
    
    # Posture: check if watcher has been active in last 60 seconds
    db_path = Path.home() / ".mcp-tools" / "mcp-server-manager" / "knowledge.db"
    has_watcher = False
    if db_path.exists():
        try:
            conn = sqlite3.connect(db_path)
            c = conn.cursor()
            c.execute("SELECT COUNT(*) FROM links WHERE categories = 'debug' AND url LIKE 'log://watcher/%'")
            count = c.fetchone()[0]
            if count > 0:
                has_watcher = True
            conn.close()
        except OSError as e:
            logger.error(f"OS error: {e}", exc_info=True)
            pass

    return jsonify({
        "activator": "online" if (bin_dir / "mcp-activator").exists() else "missing",
        "observer": "online" if (bin_dir / "mcp-observer").exists() else "missing",
        "surgeon": "online" if (bin_dir / "mcp-surgeon").exists() else "missing",
        "librarian": "online" if is_running("mcp.py") or is_running("nexus-librarian") else "stopped",
        "posture": "Live Tracking" if has_watcher else "Standard Operation",
        "servers": servers
    })

@app.route('/artifacts', methods=['GET'])
def get_artifacts():
    """List recent artifacts and their disk locations."""
    artifact_dir = Path.home() / ".mcpinv" / "artifacts"
    if not artifact_dir.exists():
        return jsonify([])
    
    results = []
    for f in sorted(artifact_dir.glob("*"), key=os.path.getmtime, reverse=True)[:50]:
        results.append({
            "name": f.name,
            "path": str(f),
            "size": f.stat().st_size,
            "modified": os.path.getmtime(f)
        })
    return jsonify(results)

@app.route('/server/control', methods=['POST'])
def control_server():
    """
    Start or stop an MCP server by ID.
    
    THREAT MODEL:
    - Receives untrusted server ID and action from HTTP POST
    - Command string comes from inventory file (trusted)
    - Uses subprocess.Popen() with list-based argv (no shell injection)
    - Process signals are sent via os.kill() with SIGTERM (safe termination)
    
    SECURITY ASSUMPTIONS:
    - Server ID is looked up in trusted inventory file first
    - Command is parsed as argv list (not passed to shell)
    - Process termination uses SIGTERM (not SIGKILL; allows graceful shutdown)
    - Runtime PIDs are stored in user-writable file (checked on each call)
    
    ERROR HANDLING:
    - FileNotFoundError: Returns 404 if inventory/runtime not found
    - json.JSONDecodeError: Returns 500 (error reading files)
    - ProcessLookupError: Returns 404 if PID no longer exists
    - Subprocess exceptions: Caught and returned as 500 error
    
    Request JSON:
        {"id": "server-name", "action": "start" or "stop"}
        
    Returns:
        JSON: {"status": "starting"|"stopped", "pid": <int>} or error dict
    """
    from flask import request
    data = request.json
    s_id = data.get("id")
    action = data.get("action") # "start" or "stop"
    runtime_path = Path.home() / ".mcpinv" / "runtime.json"
    
    inventory_path = Path.home() / ".mcpinv" / "inventory.json"
    if not inventory_path.exists():
        return jsonify({"error": "No inventory found"}), 404
    
    try:
        with open(inventory_path, "r") as f:
            inventory = json.load(f)
        
        server = inventory.get("servers", {}).get(s_id)
        if not server:
            return jsonify({"error": "Server not found"}), 404
        
        # Load running pids
        pids = {}
        if runtime_path.exists():
            with open(runtime_path, "r") as f:
                pids = json.load(f)

        if action == "start":
            cmd = server.get("command")
            if not cmd:
                return jsonify({"error": "No start command defined for this server"}), 400
            
            import subprocess
            # SECURITY: avoid shell=True. Treat inventory commands as argv, not shell strings.
            argv = shlex.split(cmd) if isinstance(cmd, str) else cmd
            if not isinstance(argv, list) or not argv:
                return jsonify({"error": "Invalid start command"}), 400
            proc = subprocess.Popen(argv, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            pids[s_id] = proc.pid
            
            with open(runtime_path, "w") as f:
                json.dump(pids, f)
                
            return jsonify({"status": "starting", "pid": proc.pid})
            
        elif action == "stop":
            pid = pids.get(s_id)
            if pid:
                import signal
                try:
                    os.kill(pid, signal.SIGTERM)
                    del pids[s_id]
                    with open(runtime_path, "w") as f:
                        json.dump(pids, f)
                    return jsonify({"status": "stopped"})
                except ProcessLookupError:
                    return jsonify({"status": "error", "message": "Process not found"}), 404
            return jsonify({"status": "error", "message": "No PID recorded for this server"}), 400
            
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    # Running on 5001 to avoid conflict with standard Streamlit/Vite ports
    print("ðŸš€ Starting GUI Bridge on port 5001...")
    # debug=True causes reloader issues in some environments.
    # SECURITY: bind to loopback by default; allow override for special dev setups.
    host = os.environ.get("NEXUS_BIND", "127.0.0.1")
    app.run(host=host, port=5001, debug=False)
